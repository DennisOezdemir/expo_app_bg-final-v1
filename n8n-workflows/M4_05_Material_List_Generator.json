{
  "name": "M4_05_Material_List_Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "m4-05-material-list",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "m405-0001-4000-8000-000000000001",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300],
      "webhookId": "m4-05-material-list",
      "notes": "Receives PROJECT_POSITIONS_CONFIRMED events from MX_00_Event_Router"
    },
    {
      "parameters": {
        "jsCode": "// Extract event data from router payload\nconst input = $input.first().json;\n\nconst eventId = input.body?.event_id || input.event_id;\nconst projectId = input.body?.project_id || input.project_id;\nconst payload = input.body?.payload || input.payload || {};\n\nconst stepKey = `material_list:${projectId}`;\n\nreturn {\n  json: {\n    event_id: eventId,\n    project_id: projectId,\n    step_key: stepKey,\n    payload: payload\n  }\n};"
      },
      "id": "m405-0002-4000-8000-000000000002",
      "name": "Parse Event Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [420, 300],
      "notes": "Extracts project_id and calculates step_key"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM claim_workflow_step(\n  '{{ $json.step_key }}',\n  '{{ $json.project_id }}'::uuid,\n  'MATERIAL_LIST_GENERATE'\n);",
        "options": {}
      },
      "id": "m405-0003-4000-8000-000000000003",
      "name": "Claim Workflow Step",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [640, 300],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      },
      "notes": "Atomic claim to prevent duplicate processing"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "check-claimed",
              "leftValue": "={{ $json.claimed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "m405-0004-4000-8000-000000000004",
      "name": "Step Claimed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [860, 300],
      "notes": "If claimed=true: proceed. If false: skip (idempotent)"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  op.id as position_id,\n  op.position_number,\n  COALESCE(op.catalog_code, '') as catalog_code,\n  op.title,\n  op.quantity,\n  op.unit,\n  op.trade::text as trade,\n  os.title as room_name,\n  os.id as section_id,\n  os.room_measurement_id,\n  p.project_number,\n  p.name as project_name,\n  p.object_street\nFROM offer_positions op\nJOIN offer_sections os ON op.section_id = os.id\nJOIN offers o ON op.offer_id = o.id\nJOIN projects p ON o.project_id = p.id\nWHERE o.project_id = '{{ $('Parse Event Data').item.json.project_id }}'::uuid\n  AND op.deleted_at IS NULL\nORDER BY os.sort_order, op.sort_order;",
        "options": {}
      },
      "id": "m405-0005-4000-8000-000000000005",
      "name": "Load Positions",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1080, 180],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      },
      "notes": "Step 1: Load all offer positions with room/project info"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id,\n  room_name,\n  floor_area_m2,\n  wall_area_m2,\n  ceiling_area_m2,\n  COALESCE(floor_perimeter_m, perimeter_m) as room_perimeter_m,\n  room_height_m\nFROM project_room_measurements\nWHERE project_id = '{{ $('Parse Event Data').item.json.project_id }}'::uuid;",
        "options": {}
      },
      "id": "m405-0006-4000-8000-000000000006",
      "name": "Load Room Measurements",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1080, 420],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      },
      "notes": "Step 2: Load room measurements (MagicPlan data)"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id,\n  catalog_position_nr,\n  catalog_source,\n  material_name,\n  default_qty,\n  unit,\n  gewerk,\n  product_pool_id,\n  multiplier_field,\n  multiplier_factor,\n  note\nFROM catalog_material_mapping\nWHERE is_active = true\nORDER BY catalog_position_nr, gewerk;",
        "options": {}
      },
      "id": "m405-0007-4000-8000-000000000007",
      "name": "Load Material Mappings",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1080, 600],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      },
      "notes": "Step 3: Load all active catalog_material_mapping entries"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// Step 4+5: CALCULATE QUANTITIES + CONSOLIDATE\n// ============================================================\n\nconst positions = $('Load Positions').all().map(i => i.json);\nconst rooms = $('Load Room Measurements').all().map(i => i.json);\nconst mappings = $('Load Material Mappings').all().map(i => i.json);\nconst eventData = $('Parse Event Data').first().json;\n\n// Build room lookup by measurement_id and by room_name (fuzzy)\nconst roomById = {};\nconst roomByName = {};\nfor (const r of rooms) {\n  roomById[r.id] = r;\n  // Normalize room name for matching\n  const normName = r.room_name.toLowerCase().replace(/\\s+\\d+$/, '').trim();\n  roomByName[normName] = r;\n  roomByName[r.room_name.toLowerCase().trim()] = r;\n}\n\n// Build mapping lookup: catalog_code → [mappings]\nconst mappingLookup = {};\nfor (const m of mappings) {\n  const key = m.catalog_position_nr;\n  if (!mappingLookup[key]) mappingLookup[key] = [];\n  mappingLookup[key].push(m);\n}\n\n// Project info from first position\nconst projectInfo = positions.length > 0 ? {\n  project_number: positions[0].project_number,\n  project_name: positions[0].project_name,\n  object_street: positions[0].object_street\n} : { project_number: 'N/A', project_name: 'N/A', object_street: 'N/A' };\n\n// Detail: per-room, per-position material lines\nconst detail = [];\n// Track unmatched positions\nconst unmatchedPositions = new Set();\n\nfor (const pos of positions) {\n  // Try matching catalog_code to mappings\n  const catalogCode = (pos.catalog_code || '').trim();\n  const materialMappings = mappingLookup[catalogCode] || [];\n\n  if (materialMappings.length === 0) {\n    unmatchedPositions.add(catalogCode || `pos_${pos.position_number}`);\n    continue;\n  }\n\n  // Find room for this position\n  let room = null;\n  if (pos.room_measurement_id) {\n    room = roomById[pos.room_measurement_id];\n  }\n  if (!room && pos.room_name) {\n    const normRoomName = pos.room_name.toLowerCase().replace(/\\s+\\d+$/, '').trim();\n    room = roomByName[pos.room_name.toLowerCase().trim()] || roomByName[normRoomName];\n  }\n\n  for (const mapping of materialMappings) {\n    let finalQty;\n\n    if (!mapping.multiplier_field) {\n      // Fixed quantity\n      finalQty = mapping.default_qty * mapping.multiplier_factor;\n    } else if (mapping.multiplier_field === 'position_qty') {\n      finalQty = (pos.quantity || 1) * mapping.default_qty * mapping.multiplier_factor;\n    } else {\n      // Room-area-based: floor_area_m2, wall_area_m2, room_perimeter_m, ceiling_area_m2\n      const areaValue = room ? (parseFloat(room[mapping.multiplier_field]) || 0) : 0;\n      finalQty = areaValue * mapping.default_qty * mapping.multiplier_factor;\n    }\n\n    // Round up to sensible units\n    if (['Sack', 'Eimer', 'Kanister', 'Dose'].includes(mapping.unit)) {\n      finalQty = Math.ceil(finalQty);\n    } else if (['St', 'Set'].includes(mapping.unit)) {\n      finalQty = Math.ceil(finalQty);\n    } else {\n      finalQty = Math.round(finalQty * 100) / 100; // 2 decimals for m², lfm, kg\n    }\n\n    if (finalQty > 0) {\n      detail.push({\n        room: pos.room_name || 'Allgemein',\n        position_nr: catalogCode,\n        material_name: mapping.material_name,\n        qty: finalQty,\n        unit: mapping.unit,\n        gewerk: mapping.gewerk,\n        product_pool_id: mapping.product_pool_id || null,\n        note: mapping.note || null\n      });\n    }\n  }\n}\n\n// Step 5: CONSOLIDATE — group by (material_name + unit + gewerk)\nconst consolidated = {};\nfor (const d of detail) {\n  const key = `${d.gewerk}||${d.material_name}||${d.unit}`;\n  if (!consolidated[key]) {\n    consolidated[key] = {\n      gewerk: d.gewerk,\n      material_name: d.material_name,\n      total_qty: 0,\n      unit: d.unit,\n      rooms: new Set(),\n      product_pool_id: d.product_pool_id\n    };\n  }\n  consolidated[key].total_qty += d.qty;\n  consolidated[key].rooms.add(d.room);\n}\n\n// Convert to array, round totals\nconst consolidatedArr = Object.values(consolidated).map(c => ({\n  gewerk: c.gewerk,\n  material_name: c.material_name,\n  total_qty: ['Sack', 'Eimer', 'Kanister', 'Dose', 'St', 'Set'].includes(c.unit)\n    ? Math.ceil(c.total_qty)\n    : Math.round(c.total_qty * 100) / 100,\n  unit: c.unit,\n  rooms: Array.from(c.rooms),\n  product_pool_id: c.product_pool_id\n})).sort((a, b) => a.gewerk.localeCompare(b.gewerk) || a.material_name.localeCompare(b.material_name));\n\n// Stats\nconst gewerke = [...new Set(consolidatedArr.map(c => c.gewerk))];\nconst totalItems = consolidatedArr.length;\nconst totalGewerke = gewerke.length;\nconst roomNames = [...new Set(detail.map(d => d.room))];\n\nreturn {\n  json: {\n    project_id: eventData.project_id,\n    step_key: eventData.step_key,\n    event_id: eventData.event_id,\n    project_number: projectInfo.project_number,\n    project_name: projectInfo.project_name,\n    object_street: projectInfo.object_street,\n    detail: detail,\n    consolidated: consolidatedArr,\n    stats: {\n      total_items: totalItems,\n      total_gewerke: totalGewerke,\n      total_detail_lines: detail.length,\n      gewerke: gewerke,\n      rooms: roomNames,\n      unmatched_positions: Array.from(unmatchedPositions)\n    }\n  }\n};"
      },
      "id": "m405-0008-4000-8000-000000000008",
      "name": "Calculate + Consolidate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 300],
      "notes": "Steps 4+5: For each position, lookup materials, calculate qty from room data, consolidate by gewerk"
    },
    {
      "parameters": {
        "jsCode": "// Step 6: Build SQL for UPSERT into project_material_needs\n// Using detail rows (per-room) with ON CONFLICT idempotency\nconst data = $input.first().json;\nconst detail = data.detail;\nconst projectId = data.project_id;\n\nif (detail.length === 0) {\n  return { json: { sql: '-- No materials to write', rows_affected: 0, ...data } };\n}\n\n// Build VALUES clause\nconst valueRows = detail.map(d => {\n  const label = d.material_name.replace(/'/g, \"''\");\n  const room = (d.room || 'Allgemein').replace(/'/g, \"''\");\n  const gewerk = d.gewerk.replace(/'/g, \"''\");\n  const note = d.note ? d.note.replace(/'/g, \"''\") : null;\n  const posNr = d.position_nr.replace(/'/g, \"''\");\n  const productId = d.product_pool_id ? `'${d.product_pool_id}'::uuid` : 'NULL';\n  \n  return `(\n    '${projectId}'::uuid,\n    '${room}',\n    '${gewerk}',\n    '${gewerk}',\n    '${label}',\n    ${d.qty},\n    '${d.unit}',\n    ${productId},\n    '${posNr}',\n    'planned',\n    'auto'\n  )`;\n}).join(',\\n');\n\nconst sql = `INSERT INTO project_material_needs (\n  project_id, room, trade, material_type, label,\n  total_quantity, quantity_unit, product_id,\n  source_position_nr, status, source\n) VALUES\n${valueRows}\nON CONFLICT (project_id, label, COALESCE(room, '__all__'))\nDO UPDATE SET\n  total_quantity = EXCLUDED.total_quantity,\n  trade = EXCLUDED.trade,\n  source_position_nr = EXCLUDED.source_position_nr,\n  updated_at = now()\nRETURNING id;`;\n\nreturn { json: { sql, ...data } };"
      },
      "id": "m405-0009-4000-8000-000000000009",
      "name": "Build Upsert SQL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 300],
      "notes": "Step 6a: Builds idempotent UPSERT SQL for project_material_needs"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {}
      },
      "id": "m405-0010-4000-8000-000000000010",
      "name": "Write Materials to DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1820, 300],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      },
      "notes": "Step 6b: Execute UPSERT — idempotent, ON CONFLICT updates qty"
    },
    {
      "parameters": {
        "jsCode": "// Merge write result with calculation data\nconst writeResult = $input.all().map(i => i.json);\nconst calcData = $('Calculate + Consolidate').first().json;\n\nreturn {\n  json: {\n    ...calcData,\n    rows_written: writeResult.length\n  }\n};"
      },
      "id": "m405-0011-4000-8000-000000000011",
      "name": "Merge Write Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2040, 300],
      "notes": "Merges DB write result count with calculation data"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT complete_workflow_step(\n  '{{ $json.step_key }}',\n  '{\"materials_written\": {{ $json.rows_written }}, \"total_items\": {{ $json.stats.total_items }}}'\n);",
        "options": {}
      },
      "id": "m405-0012-4000-8000-000000000012",
      "name": "Complete Workflow Step",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [2260, 300],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      },
      "notes": "Marks workflow step as DONE with summary payload"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Mark input event as processed\nDO $$ BEGIN\n  UPDATE events SET processed_at = now() WHERE id = '{{ $('Merge Write Result').item.json.event_id }}'::uuid;\nEXCEPTION WHEN invalid_text_representation THEN NULL;\nEND $$;\n\n-- Emit MATERIAL_LIST_GENERATED event\nINSERT INTO events (event_type, project_id, payload, source_system, source_flow, reference_table, reference_id, dedupe_key)\nVALUES (\n  'MATERIAL_LIST_GENERATED',\n  '{{ $('Merge Write Result').item.json.project_id }}'::uuid,\n  jsonb_build_object(\n    'total_items', {{ $('Merge Write Result').item.json.stats.total_items }},\n    'total_gewerke', {{ $('Merge Write Result').item.json.stats.total_gewerke }},\n    'total_detail_lines', {{ $('Merge Write Result').item.json.stats.total_detail_lines }},\n    'gewerke', '{{ JSON.stringify($('Merge Write Result').item.json.stats.gewerke) }}'::jsonb,\n    'unmatched_positions', '{{ JSON.stringify($('Merge Write Result').item.json.stats.unmatched_positions) }}'::jsonb\n  ),\n  'n8n',\n  'M4_05_Material_List_Generator',\n  'projects',\n  '{{ $('Merge Write Result').item.json.project_id }}'::uuid,\n  'mat_list_' || '{{ $('Merge Write Result').item.json.project_id }}'\n)\nON CONFLICT (source_system, dedupe_key) WHERE dedupe_key IS NOT NULL\nDO UPDATE SET payload = EXCLUDED.payload, created_at = NOW()\nRETURNING id, event_type::text, project_id;",
        "options": {}
      },
      "id": "m405-0013-4000-8000-000000000013",
      "name": "Emit MATERIAL_LIST_GENERATED",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [2480, 300],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      },
      "notes": "Step 7: Marks input event processed and emits MATERIAL_LIST_GENERATED"
    },
    {
      "parameters": {
        "chatId": "6088921678",
        "text": "=\ud83d\udce6 *Materialliste generiert*\n\n\ud83d\udccd {{ $('Merge Write Result').item.json.project_number }} \u00b7 {{ $('Merge Write Result').item.json.object_street }}\n\n\ud83d\udccb {{ $('Merge Write Result').item.json.stats.total_items }} Artikel, {{ $('Merge Write Result').item.json.stats.total_gewerke }} Gewerke\n\ud83c\udfe0 {{ $('Merge Write Result').item.json.stats.rooms.length }} R\u00e4ume\n\ud83d\udcdd {{ $('Merge Write Result').item.json.stats.total_detail_lines }} Detail-Positionen\n\n{{ $('Merge Write Result').item.json.stats.unmatched_positions.length > 0 ? '\u26a0\ufe0f ' + $('Merge Write Result').item.json.stats.unmatched_positions.length + ' Positionen ohne Mapping' : '\u2705 Alle Positionen gemappt' }}\n\n\u2192 Zur Freigabe im Material-Center",
        "additionalFields": {
          "disable_web_page_preview": true,
          "parse_mode": "Markdown"
        }
      },
      "id": "m405-0014-4000-8000-000000000014",
      "name": "Telegram Notify",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2700, 300],
      "notes": "Step 8: Sends material list summary to Dennis via Telegram"
    },
    {
      "parameters": {
        "jsCode": "const data = $('Merge Write Result').first().json;\nreturn {\n  json: {\n    success: true,\n    project_id: data.project_id,\n    total_items: data.stats.total_items,\n    total_gewerke: data.stats.total_gewerke,\n    total_detail_lines: data.stats.total_detail_lines,\n    rows_written: data.rows_written,\n    unmatched_positions: data.stats.unmatched_positions\n  }\n};"
      },
      "id": "m405-0015-4000-8000-000000000015",
      "name": "Done (Success)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2920, 300],
      "notes": "Success response with summary stats"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "m405-0016-4000-8000-000000000016",
      "name": "Respond (Success)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3140, 300]
    },
    {
      "parameters": {
        "jsCode": "// Step already done or in progress by another run\nconst claimResult = $input.first().json;\nconst eventData = $('Parse Event Data').first().json;\n\nif (claimResult.current_status === 'DONE') {\n  return {\n    json: {\n      status: 'skipped',\n      reason: 'Material list already generated for this project',\n      current_status: claimResult.current_status,\n      project_id: eventData.project_id\n    }\n  };\n}\n\nreturn {\n  json: {\n    status: 'skipped',\n    reason: 'Step in progress by another run',\n    current_status: claimResult.current_status\n  }\n};"
      },
      "id": "m405-0017-4000-8000-000000000017",
      "name": "Handle Not Claimed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1080, 540],
      "notes": "Handles duplicate trigger — returns skip response"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "m405-0018-4000-8000-000000000018",
      "name": "Respond (Skip)",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1300, 540]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [{ "node": "Parse Event Data", "type": "main", "index": 0 }]
      ]
    },
    "Parse Event Data": {
      "main": [
        [{ "node": "Claim Workflow Step", "type": "main", "index": 0 }]
      ]
    },
    "Claim Workflow Step": {
      "main": [
        [{ "node": "Step Claimed?", "type": "main", "index": 0 }]
      ]
    },
    "Step Claimed?": {
      "main": [
        [
          { "node": "Load Positions", "type": "main", "index": 0 },
          { "node": "Load Room Measurements", "type": "main", "index": 0 },
          { "node": "Load Material Mappings", "type": "main", "index": 0 }
        ],
        [{ "node": "Handle Not Claimed", "type": "main", "index": 0 }]
      ]
    },
    "Load Positions": {
      "main": [
        [{ "node": "Calculate + Consolidate", "type": "main", "index": 0 }]
      ]
    },
    "Load Room Measurements": {
      "main": [
        [{ "node": "Calculate + Consolidate", "type": "main", "index": 0 }]
      ]
    },
    "Load Material Mappings": {
      "main": [
        [{ "node": "Calculate + Consolidate", "type": "main", "index": 0 }]
      ]
    },
    "Calculate + Consolidate": {
      "main": [
        [{ "node": "Build Upsert SQL", "type": "main", "index": 0 }]
      ]
    },
    "Build Upsert SQL": {
      "main": [
        [{ "node": "Write Materials to DB", "type": "main", "index": 0 }]
      ]
    },
    "Write Materials to DB": {
      "main": [
        [{ "node": "Merge Write Result", "type": "main", "index": 0 }]
      ]
    },
    "Merge Write Result": {
      "main": [
        [{ "node": "Complete Workflow Step", "type": "main", "index": 0 }]
      ]
    },
    "Complete Workflow Step": {
      "main": [
        [{ "node": "Emit MATERIAL_LIST_GENERATED", "type": "main", "index": 0 }]
      ]
    },
    "Emit MATERIAL_LIST_GENERATED": {
      "main": [
        [{ "node": "Telegram Notify", "type": "main", "index": 0 }]
      ]
    },
    "Telegram Notify": {
      "main": [
        [{ "node": "Done (Success)", "type": "main", "index": 0 }]
      ]
    },
    "Done (Success)": {
      "main": [
        [{ "node": "Respond (Success)", "type": "main", "index": 0 }]
      ]
    },
    "Handle Not Claimed": {
      "main": [
        [{ "node": "Respond (Skip)", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": true,
    "errorWorkflow": "apmJoMCbOchwfqTp"
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "tags": []
}
