{
  "name": "M6_03_Lexware_Pull_Sales",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [{ "field": "minutes", "minutesInterval": 15 }]
        }
      },
      "id": "d6030001-0001-4000-8000-000000000001",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [200, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COALESCE(\n  to_char(MAX(lexware_last_synced_at) AT TIME ZONE 'Europe/Berlin',\n    'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"+01:00\"'),\n  '2025-01-01T00:00:00.000+01:00'\n) as last_sync\nFROM sales_invoices\nWHERE source = 'lexware';",
        "options": {}
      },
      "id": "d6030001-0002-4000-8000-000000000002",
      "name": "Get Last Sync Time",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [420, 300],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.lexware.io/v1/voucherlist",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            { "name": "voucherType", "value": "invoice,creditnote,downpaymentinvoice" },
            { "name": "voucherStatus", "value": "open,paid,paidoff,voided" },
            { "name": "updatedDateFrom", "value": "={{ $('Get Last Sync Time').item.json.last_sync }}" },
            { "name": "page", "value": "0" },
            { "name": "size", "value": "250" },
            { "name": "sort", "value": "updatedDate,ASC" }
          ]
        },
        "options": {}
      },
      "id": "d6030001-0003-4000-8000-000000000003",
      "name": "Fetch Voucherlist Main",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [640, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "LEXWARE_CREDENTIAL_ID",
          "name": "Lexware API"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.lexware.io/v1/voucherlist",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            { "name": "voucherType", "value": "invoice" },
            { "name": "voucherStatus", "value": "overdue" },
            { "name": "page", "value": "0" },
            { "name": "size", "value": "250" },
            { "name": "sort", "value": "updatedDate,ASC" }
          ]
        },
        "options": {}
      },
      "id": "d6030001-0004-4000-8000-000000000004",
      "name": "Fetch Voucherlist Overdue",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [860, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "LEXWARE_CREDENTIAL_ID",
          "name": "Lexware API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge main + overdue voucherlists, deduplicate, prepare detail URLs\nconst mainData = $('Fetch Voucherlist Main').first().json;\nconst overdueData = $('Fetch Voucherlist Overdue').first().json;\n\nconst mainContent = mainData.content || [];\nconst overdueContent = overdueData.content || [];\n\n// Deduplicate: overdue overrides main\nconst map = new Map();\nfor (const v of mainContent) map.set(v.id, v);\nfor (const v of overdueContent) map.set(v.id, { ...v, voucherStatus: 'overdue' });\n\nconst merged = Array.from(map.values());\n\nif (merged.length === 0) {\n  return { json: { _empty: true, count: 0 } };\n}\n\n// Each item gets a detail_url for the next HTTP Request node\nreturn merged.map(v => ({\n  json: {\n    voucher_id: v.id,\n    voucher_type: v.voucherType,\n    voucher_status: v.voucherStatus,\n    voucher_number: v.voucherNumber,\n    voucher_date: v.voucherDate,\n    due_date: v.dueDate || null,\n    contact_id: v.contactId || null,\n    contact_name: v.contactName || null,\n    total_amount: v.totalAmount || 0,\n    open_amount: v.openAmount || 0,\n    currency: v.currency || 'EUR',\n    updated_date: v.updatedDate,\n    detail_url: v.voucherType === 'creditnote'\n      ? `https://api.lexware.io/v1/credit-notes/${v.id}`\n      : `https://api.lexware.io/v1/invoices/${v.id}`\n  }\n}));"
      },
      "id": "d6030001-0005-4000-8000-000000000005",
      "name": "Merge & Prepare Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict", "version": 2 },
          "conditions": [{
            "id": "empty-check",
            "leftValue": "={{ $json._empty }}",
            "rightValue": true,
            "operator": { "type": "boolean", "operation": "equals" }
          }],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "d6030001-0006-4000-8000-000000000006",
      "name": "Has Vouchers?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "jsCode": "return { json: { status: 'idle', message: 'No updated invoices from Lexware' } };"
      },
      "id": "d6030001-0007-4000-8000-000000000007",
      "name": "No Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1520, 180]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.detail_url }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "d6030001-0008-4000-8000-000000000008",
      "name": "Fetch Detail",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1520, 420],
      "credentials": {
        "httpHeaderAuth": {
          "id": "LEXWARE_CREDENTIAL_ID",
          "name": "Lexware API"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Map Lexware detail to BG sales_invoices schema\nconst detail = $json;\nconst voucher = $('Merge & Prepare Items').item.json;\n\n// Type mapping\nconst typeMap = { 'invoice': 'SCHLUSS', 'creditnote': 'GUTSCHRIFT', 'downpaymentinvoice': 'ABSCHLAG' };\nconst statusMap = { 'draft': 'DRAFT', 'open': 'SENT', 'paid': 'PAID', 'paidoff': 'PAIDOFF', 'voided': 'VOIDED', 'overdue': 'OVERDUE', 'accepted': 'SENT', 'rejected': 'REJECTED' };\n\nconst totalPrice = detail.totalPrice || {};\nconst address = detail.address || {};\nconst addressStr = [address.street, `${address.zip || ''} ${address.city || ''}`].filter(Boolean).join(', ').trim();\nconst extractDate = (d) => d ? d.substring(0, 10) : null;\n\nreturn {\n  json: {\n    voucher_id: voucher.voucher_id,\n    voucher_number: detail.voucherNumber || voucher.voucher_number,\n    invoice_type: typeMap[voucher.voucher_type] || 'SCHLUSS',\n    status: statusMap[voucher.voucher_status] || 'SENT',\n    invoice_date: extractDate(detail.voucherDate || voucher.voucher_date),\n    due_date: extractDate(detail.dueDate || voucher.due_date),\n    total_net: totalPrice.totalNetAmount || 0,\n    vat_amount: totalPrice.totalTaxAmount || 0,\n    total_gross: totalPrice.totalGrossAmount || voucher.total_amount || 0,\n    vat_rate: 19,\n    currency: totalPrice.currency || voucher.currency || 'EUR',\n    customer_name: (address.name || voucher.contact_name || '').replace(/'/g, \"''\"),\n    customer_address: addressStr.replace(/'/g, \"''\"),\n    lexware_contact_id: address.contactId || voucher.contact_id || null,\n    raw_data: JSON.stringify(detail).replace(/'/g, \"''\")\n  }\n};"
      },
      "id": "d6030001-0009-4000-8000-000000000009",
      "name": "Build Upsert Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 420]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO sales_invoices (\n  lexware_invoice_id, invoice_number, invoice_type, status,\n  invoice_date, due_date, total_net, total_vat, total_gross,\n  vat_rate, currency, customer_name, customer_address,\n  lexware_contact_id, lexware_last_synced_at, lexware_synced_at,\n  lexware_raw_data, lexware_sync_status, source\n) VALUES (\n  '{{ $json.voucher_id }}',\n  '{{ $json.voucher_number }}',\n  '{{ $json.invoice_type }}'::sales_invoice_type,\n  '{{ $json.status }}'::sales_invoice_status,\n  '{{ $json.invoice_date }}'::date,\n  {{ $json.due_date ? \"'\" + $json.due_date + \"'::date\" : 'NULL' }},\n  {{ $json.total_net }}, {{ $json.vat_amount }}, {{ $json.total_gross }},\n  {{ $json.vat_rate }}, '{{ $json.currency }}',\n  '{{ $json.customer_name }}', '{{ $json.customer_address }}',\n  {{ $json.lexware_contact_id ? \"'\" + $json.lexware_contact_id + \"'\" : 'NULL' }},\n  now(), now(),\n  '{{ $json.raw_data }}'::jsonb, 'synced', 'lexware'\n)\nON CONFLICT (lexware_invoice_id) DO UPDATE SET\n  status = EXCLUDED.status, due_date = EXCLUDED.due_date,\n  total_net = EXCLUDED.total_net, total_vat = EXCLUDED.total_vat,\n  total_gross = EXCLUDED.total_gross,\n  customer_name = EXCLUDED.customer_name, customer_address = EXCLUDED.customer_address,\n  lexware_contact_id = EXCLUDED.lexware_contact_id,\n  lexware_last_synced_at = now(), lexware_synced_at = now(),\n  lexware_raw_data = EXCLUDED.lexware_raw_data, lexware_sync_status = 'synced'\nRETURNING id, invoice_number, status::text,\n  (xmax = 0) as is_new;",
        "options": {}
      },
      "id": "d6030001-0010-4000-8000-000000000010",
      "name": "Upsert Sales Invoice",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1960, 420],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Auto-match client\nWITH match AS (\n  SELECT c.id FROM clients c\n  WHERE c.company_name ILIKE '%' || '{{ $('Build Upsert Data').item.json.customer_name }}' || '%'\n  LIMIT 1\n)\nUPDATE sales_invoices si SET client_id = match.id\nFROM match\nWHERE si.id = '{{ $json.id }}'::uuid AND si.client_id IS NULL;\n\n-- Sync log\nINSERT INTO lexware_sync_log (sync_direction, entity_type, entity_id, lexware_id, action, sync_status)\nVALUES ('pull', 'sales_invoice', '{{ $json.id }}'::uuid,\n  '{{ $('Build Upsert Data').item.json.voucher_id }}',\n  CASE WHEN {{ $json.is_new }} THEN 'create' ELSE 'update' END,\n  'success');",
        "options": {}
      },
      "id": "d6030001-0011-4000-8000-000000000011",
      "name": "Auto-Match + Log",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [2180, 420],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nreturn { json: { status: 'completed', total: items.length } };"
      },
      "id": "d6030001-0012-4000-8000-000000000012",
      "name": "Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 420]
    },
    {
      "parameters": {
        "jsCode": "// Detail fetch error â€” log and skip this item\nconst voucher = $('Merge & Prepare Items').item.json;\nreturn { json: { voucher_id: voucher.voucher_id, error: true } };"
      },
      "id": "d6030001-0013-4000-8000-000000000013",
      "name": "Handle Detail Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 600]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO lexware_sync_log (sync_direction, entity_type, lexware_id, action, sync_status, error_message)\nVALUES ('pull', 'sales_invoice', '{{ $json.voucher_id }}', 'fetch', 'error', 'Detail fetch failed');",
        "options": {}
      },
      "id": "d6030001-0014-4000-8000-000000000014",
      "name": "Log Error",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1960, 600],
      "credentials": {
        "postgres": {
          "id": "qXZ2ZjK31ZDrPoDG",
          "name": "Supabase Postgres"
        }
      }
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [[{ "node": "Get Last Sync Time", "type": "main", "index": 0 }]]
    },
    "Get Last Sync Time": {
      "main": [[{ "node": "Fetch Voucherlist Main", "type": "main", "index": 0 }]]
    },
    "Fetch Voucherlist Main": {
      "main": [[{ "node": "Fetch Voucherlist Overdue", "type": "main", "index": 0 }]]
    },
    "Fetch Voucherlist Overdue": {
      "main": [[{ "node": "Merge & Prepare Items", "type": "main", "index": 0 }]]
    },
    "Merge & Prepare Items": {
      "main": [[{ "node": "Has Vouchers?", "type": "main", "index": 0 }]]
    },
    "Has Vouchers?": {
      "main": [
        [{ "node": "No Updates", "type": "main", "index": 0 }],
        [{ "node": "Fetch Detail", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Detail": {
      "main": [
        [{ "node": "Build Upsert Data", "type": "main", "index": 0 }],
        [{ "node": "Handle Detail Error", "type": "main", "index": 0 }]
      ]
    },
    "Build Upsert Data": {
      "main": [[{ "node": "Upsert Sales Invoice", "type": "main", "index": 0 }]]
    },
    "Upsert Sales Invoice": {
      "main": [[{ "node": "Auto-Match + Log", "type": "main", "index": 0 }]]
    },
    "Auto-Match + Log": {
      "main": [[{ "node": "Summary", "type": "main", "index": 0 }]]
    },
    "Handle Detail Error": {
      "main": [[{ "node": "Log Error", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": true,
    "errorWorkflow": "apmJoMCbOchwfqTp"
  },
  "meta": { "templateCredsSetupCompleted": true },
  "tags": []
}
